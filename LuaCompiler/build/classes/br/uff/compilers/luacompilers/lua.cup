package br.uff.compilers.luacompilers;

import java_cup.runtime.*;
import java.io.FileReader;

parser code
{:
    // Funções chamadas em erros ///////////////////////////////////////////////////////////////////////////
    public void syntax_error(Symbol s){ 
        System.out.println("\nOcorreu um erro na linha " + (s.right) +", coluna "+s.left+ ". Identificador "
        +s.value + " não reconhecido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("\nOcorreu um erro na linha " + (s.right)+ ", coluna "+s.left+". Identificador " +
        s.value + " não reconhecido.");
    }
    
    public static void main(String[] args){
        try {
            LuaParser parser = new LuaParser(new LuaLexer(new FileReader(args[0])));
            Object result = parser.parse().value;
            System.out.println("*** Resultados finais ***");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////
:}


/* Terminal */
terminal Token DO, END, WHILE, REPEAT, IF, THEN, ELSE, ELSEIF, FOR, IN, UNTIL;
terminal Token FUNCTION, LOCAL, RETURN, BREAK;
terminal Token NIL, FALSE, TRUE, ELLIPSIS;
terminal Token COLON, SEMICOLON, COMMA, OPEN_BRACKETS, CLOSE_BRACKETS, OPEN_BRACES, CLOSE_BRACES, OPEN_PARENTHESES, CLOSE_PARENTHESES;
terminal Token SIGN, PLUS, MINUS, TIMES, DIV, UP_CARET, PERCENT, TWO_PERIOD, PERIOD;
terminal Token LESS_THAN, LESS_THAN_EQUAL, GREATHER_THAN, GREATHER_THAN_EQUAL, EQUAL, DIFFERENT;
terminal Token AND, OR, NOT, LENGTH;
terminal Token NUMBER, STRING, IDENTIFIER;

non terminal Node chuck;
non terminal Node block;
non terminal Node stat;
non terminal Node laststat;
non terminal Node funcname;
non terminal Node varlist;
non terminal Node var;
non terminal Node namelist;
non terminal Node explist;
non terminal Node exp;
non terminal Node prefixexp;
non terminal Node functioncall;
non terminal Node args;
non terminal Node function;
non terminal Node funcbody;
non terminal Node parlist;
non terminal Node tableconstructor;
non terminal Node fieldlist;
non terminal Node field;
non terminal Node fieldsep;
non terminal Node binop;
non terminal Node unop;

non terminal Node semicolontemp;
non terminal Node tempchuck;
non terminal Node laststattemp;
non terminal Node elseiftemp;
non terminal Node elsetemp;
non terminal Node commaexptemp;
non terminal Node signexplisttemp;
non terminal Node explisttemp;
non terminal Node periodidentifiertemp;
non terminal Node commavartemp;
non terminal Node commaidentifiertemp;
non terminal Node expcommatemp;
non terminal Node parlisttemp;
non terminal Node commaellipsistemp;
non terminal Node fieldlisttemp;
non terminal Node fieldsepfieldtemp;
non terminal Node twoperiodidentifertemp;
non terminal Node ifstatment;
non terminal Node functioncalltemp;
non terminal Node vartemp;
non terminal Node exptemp;


/* Precedences */

precedence left OR;
precedence left AND;
precedence left LESS_THAN, GREATHER_THAN, LESS_THAN_EQUAL, GREATHER_THAN_EQUAL, DIFFERENT , EQUAL;
precedence right TWO_PERIOD;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, PERCENT;
precedence left NOT;
precedence right UP_CARET;
precedence left COMMA;
precedence left OPEN_PARENTHESES;

start with chuck;

chuck ::= tempchuck:tempchuck laststattemp:laststattemp
        {:
            tempchuck.addCHildren(laststattemp);
            RESULT = tempchuck;
        :}
        ;

tempchuck ::= stat:stat semicolontemp:semicolontemp tempchuck:tempchuck
        {:
            stat.addChildren(semicolontemp);
            stat.addChildren(tempchuck);
            RESULT = stat;
        :}
        |
        ;

laststattemp ::= laststat:laststat semicolontemp:semicolontemp
        {:
            laststat.addChildren(semicolontemp);
            RESULT = laststat;
        :}
        |
        ;

block ::= chuck:chuck
        {:
            RESULT chuck;
        :}
          ;

stat ::= varlist:varlist SIGN:sign explist:explist
        {:
            // Node sign = new Node(sign);
            sign.addChildren(varlist);
            sign.addChildren(explist);
            RESULT = sign;
        :}
        | prefixexp:prefixexp
        {:
            RESULT = prefixexp;
        :}
        | DO:do block:block END:end
        {:
            Node do = new Node(do);
            Node end = new Node(end);
            do.addChildren(block);
            do.addChildren(end);
            RESULT = do;
        :}
        | WHILE:while exp:exp DO:do block:block END:end
        {:
            Node while = new Node(while);
            Node do = new Node(do);
            Node end = new Node(end);
            while.addChildren(exp);
            do.addChildren(block);
            while.addChildren(do);
            while.addChildren(end);
            RESULT = while;
        :}
        | REPEAT:repeat block:block UNTIL:until exp:exp
        {:
            Node repeat = new Node(repeat);
            Node until = new Node(until);
            repeat.addChildren(block);
            repeat.addChildren(until);
            repeat.addChildren(exp);
            RESULT = repeat;
        :}
        | ifstatment:id
        {:
            RESULT = id;
        :}
        | FOR:for IDENTIFIER:id SIGN:sign exp:exp1 COMMA:comma exp:exp2 commaexptemp:commaexptemp DO:do block:block END:end
        {:
            Node for = new Node(for);
            // Node id = new Node(id);
            // Node sign = new Node(sign); 
            // Node comma = new Node(comma);
            Node do = new Node(do);
            Node end = new Node(end);
            for.addChildren(id);
            for.addChildren(sign);
            for.addChildren(exp1);
            for.addChildren(comma);
            for.addChildren(exp2);
            for.addChildren(commaexptemp);
            do.addChildren(block);
            for.addChildren(do);
            for.addChildren(end);
            RESULT = for;
        :}
        | FOR:for namelist:namelist IN:in explist:explist DO:do block:block END:end
        {:
            Node for = new Node(for);
            Node in = new Node(in);
            Node do = new Node(do);
            Node end = new Node(end);
            for.addChildren(namelist);
            for.addChildren(in);
            do.addChildren(block);
            for.addChildren(do);
            for.addChildren(end);
            RESULT = for;
        :}
        | FUNCTION:function funcname:funcname funcbody:funcbody
        {:
            // Node function = new Node(function);
            function.addChildren(funcname);
            function.addChildren(funcbody);
            RESULT = function;
        :}
        | LOCAL:local FUNCTION:function IDENTIFIER:id funcbody:funcbody
        {:
            Node local = new Node(local);
            // Node function = new Node(function);
            // Node id = new Node(id);
            function.addChildren(id);
            function.addChildren(funcbody);
            local.addChildren(function);
            RESULT = local;
        :}
        | LOCAL:local namelist:namelist signexplisttemp:signexplisttemp
        {:
            Node local = new Node(local);
            local.addChildren(namelist);
            local.addChildren(signexplisttemp);
            RESULT = local;
        :}
        ;

ifstatment ::= IF:if exp:exp THEN:then block:block elseiftemp:elseiftemp elsetemp:elsetemp END:end
        {:
            Node if = new Node(if);
            if.addChildren(exp);
            then.addChildren(block);
            if.addChildren(then);
            if.addChildren(elseiftemp);
            if.addChildren(elsetemp);
            if.addChildren(end);
            RESULT = id;
        :}
        ;

elseiftemp ::= ELSEIF:elseif exp:exp THEN:then block:block elseiftemp:elseiftemp
        {:
            Node elseif = new Node(elseif);
            Node then = new Node(then);
            elseif.addChildren(exp);
            then.addChildren(block);
            then.addChildren(elseiftemp);
            elseif.addChildren(then);
            RESULT = elseif;
        :}
        |
        ;

elsetemp ::=  ELSE:else block:block
        {:
            Node else = new Node(else);
            block.addChildren(else);
            RESULT = block;
        :}
        |
        ;

signexplisttemp ::= SIGN:sign explist:explist
        {:
            // Node sign = new Node(sign);
            sign.addChildren(explist);
            RESULT = sign;
        :}
        |
        ;

laststat ::= RETURN:return explisttemp:explisttemp
        {:
            Node return = new Node(return);
            return.addChildren(explisttemp);
            RESULT = return;
        :}
        | BREAK:break
        {:
            RESULT new Node(break);
        :}
        ;

explisttemp ::= explist:explist
        {:
            RESULT = explist;
        :}
        |
        ;

funcname ::= IDENTIFIER:id periodidentifiertemp:periodidentifiertemp twoperiodidentifertemp:twoperiodidentifertemp
        {:
            // Node id = new Node(id);
            twoperiodidentifertemp.addChildren(id);
            twoperiodidentifertemp.addChildren(periodidentifiertemp);
            RESULT = twoperiodidentifertemp;
        :}
        ;

periodidentifiertemp ::= PERIOD:period IDENTIFIER:id periodidentifiertemp:periodidentifiertemp
        {:
            Node period = new Node(period);
            Node id = Node(id);
            periodidentifiertemp.addChildren(period);
            periodidentifiertemp.addChildren(id);
            RESULT = periodidentifiertemp;
        :}
        |
        ;

twoperiodidentifertemp ::= TWO_PERIOD:twoperiod IDENTIFIER:id
        {:  
            Node twoperiod = new Node(twoperiod);
            // Node id = new Node(id);
            id.addChildren(twoperiod);
            RESULT = id;
        :}
        |
        ;

varlist ::= var:var commavartemp:commavartemp
        {:
            commavartemp.addChildren(var);
            RESULT = commavartemp;
        :}
        ;

var ::= IDENTIFIER:id
    {:
        RESULT = new Node(id);
    :}
    | prefixexp:prefixexp vartemp:vartemp
    {:
        vartemp.addChildren(prefixexp);
        RESULT = vartemp;
    :}
    ;

vartemp ::= PERIOD:period IDENTIFIER:id
        {:
            Node period = new Node(period);
            // Node id = new Node(id);
            period.addChildren(id);
            RESULT = period;
        :}
        | OPEN_BRACKETS:openB exp:exp CLOSE_BRACKETS:closeB
        {:
            exp.addChildren(openB);
            exp.addChildren(closeB);
            RESULT = exp;
        :}
        ;

namelist ::= IDENTIFIER:id commaidentifiertemp:commaidentifiertemp
        {:
        // Node id = new Node(id);
        commaidentifiertemp.addChildren(id);
        RESULT = commaidentifiertemp;
        :}
        ;

explist ::= exp:exp expcommatemp:expcommatemp
        {:
            expcommatemp.addChildren(exp);
            RESULT = expcommatemp;
        :}
        ;

functioncall ::= prefixexp:prefixexp functioncalltemp:functioncalltemp
            {: 
                functioncalltemp.addChildren(prefixexp);
                RESULT = functioncalltemp;
 :}
            ;

functioncalltemp ::= COLON:colon IDENTIFIER:id args:args
            {:
             Node colon = new Node(colon);
             // Node id = new Node(id);
             args.addChildren(colon);
             args.addChildren(id);
             RESULT = args;
            :}


            | args:args
            {:
                RESULT = args;
            :}
            ;

function ::= FUNCTION:function funcbody:funcbody
            {:
             // Node function = new Node(function);
             funcbody.addChildren(function);
             RESULT = funcbody;
            :}
          ;

parlisttemp ::= parlist:parlist
        {:
            RESULT = parlist;
        :}
        |
        ;

parlist ::= namelist:namelist commaellipsistemp:commaellipsistemp
        {:
            commaellipsistemp.addChildren(namelist);
            RESULT = commaellipsistemp;
        :}
        | ELLIPSIS:ellipsis
        {:
             RESULT = new Node(ellipsis);
        :}
        ;

tableconstructor ::=  OPEN_BRACES:openB fieldlisttemp:fieldlisttemp CLOSE_BRACES:closeB
        {:
            fieldlisttemp.addChildren(openB);
            fieldlisttemp.addChildren(closeB);
            RESULT = fieldlisttemp;
        :}
        ;

fieldlisttemp ::= fieldlist:fieldlist
        {:
            RESULT = fieldlist;
        :}
        ;

fieldlist ::= field:field fieldsepfieldtemp:fieldsepfieldtemp
        {:
            fieldsepfieldtemp.addChildren(field);
            RESULT = fieldsepfieldtemp;
        :}
        ;

fieldsepfieldtemp ::= fieldsep:fieldsep field:field fieldsepfieldtemp:fieldsepfieldtemp 
        {:
            fieldsepfieldtemp.addChildren(fieldesp);
            fieldsepfieldtemp.addChildren(field);
            RESULT = fieldsepfieldtemp;
        :}
        
        |
        ;

field ::= OPEN_BRACKETS:openB exp:exp1 CLOSE_BRACKETS:closeB SIGN:sign exp:exp2
        {:
            exp1.addChildren(openB);
            exp1.addChildren(closeB);
            // Node sign = new Node(sign);
            sign.addChildren(exp1);
            sign.addChildren(exp2);
            RESULT = sign;
        :}
        | IDENTIFIER:id SIGN:sign exp:exp
        {:
            // Node id = new Node(id);
            // Node sign = new Node(sign);
            exp.addChildren(id);
            exp.addChildren(sign);
            RESULT = exp;
        :}
        | exp:exp
        {:
          RESULT = exp;
        :}
        |
        ;
            
binop ::= PLUS:plus
        {:
            RESULT = new Node(plus);
        :}
        | MINUS:minus
        {:
            RESULT = new Node(minus);
        :}
        | TIMES:times
        {:
            RESULT = new Node(times);
        :}
        | DIV:div
        {:
            RESULT = new Node(div);
        :}
        | UP_CARET:up_caret
        {:
            RESULT = new Node(up_caret);

        :}
        | PERCENT:percent
        {:
            RESULT = new Node(percent);
        :}
        | TWO_PERIOD:two_period
        {:
            RESULT = new Node(two_period);
        :}
        | LESS_THAN:less_than
        {:
            RESULT = new Node(less_than);
        :}
        | LESS_THAN_EQUAL:less_than_equal
        {:
            RESULT = new Node(less_than_equal);
        :}
        | GREATHER_THAN:greather_than
        {:
            RESULT = new Node(greather_than);
        :}
        | GREATHER_THAN_EQUAL:greather_than_equal
        {:
            RESULT = new Node(greather_than_equal);
        :}
        | EQUAL: equal
        {:
            RESULT = new Node(equal);

        :}
        | DIFFERENT:different
        {:
            RESULT = new Node(different);

        :}
        | AND:and
        {:
            RESULT = new Node(and);

        :}
        | OR:or
        {:
            RESULT = new Node(or);

        :}
        ;

unop ::= MINUS:minus
        {:
            RESULT = new Node(minus);
        :}
       | NOT:not
        {:
            RESULT = new Node(not);
        :}
       | LENGTH:length
        {:
            RESULT = new Node(length);
        :}
       ;

semicolontemp ::= SEMICOLON:semicolon
        {:
            RESULT = new Node(semicolon);

        :}
        |
        ;

fieldsep ::= COMMA:comma
        {:
            RESULT = new Node(comma);
        :}
        | SEMICOLON:semicolon
        {:
            RESULT = new Node(semicolon);

        :}
        ;


commaellipsistemp ::= COMMA:comma ELLIPSIS:ellipsis 
        {:
        // Node comma = new Node(comma);
        // Node ellipsis = new Node(ellipsis);
        ellipsis.addChildren(comma);
        RESULT = ellipsis;
:}
        |
        ;

expcommatemp ::= COMMA:comma exp:exp expcommatemp:expcommatemp
        {:
        // Node comma = new Node(comma);
        expcommatemp.addChildren(comma);
        expcommatemp.addChildren(exp);
        RESULT = expcommatemp;
        :}
        |
        ;

commaidentifiertemp ::= COMMA:comma IDENTIFIER:id commaidentifiertemp:commaidentifiertemp
        {:
            // Node comma = new Node(comma);
            // Node id = new Node(id);
            commaidentifiertemp.addChildren(comma);
            commaidentifiertemp.addChildren(id);
            RESULT = commaidentifiertemp;
        :}
        |
        ;

commavartemp ::= COMMA:comma var:var commavartemp:commavartemp
        {:
            // Node comma = new Node(comma);
            commavartemp.addChildren(comma);
            commavartemp.addChildren(var);
            RESULT = commavartemp;
        :}
        |
        ;

commaexptemp ::= COMMA:comma exp:exp
        {:
            // Node comma = new Node(comma);
            exp.addChildren(comma);
            RESULT = exp;
        :}
        |
        ;

args ::= OPEN_PARENTHESES:openP explisttemp:explisttemp CLOSE_PARENTHESES:closeP
        {:
            explisttemp.addChildren(openP);
            explisttemp.addChildren(closeP);
            RESULT = explisttemp;
        :}
    
       | tableconstructor:tableconstructor
       {:
          RESULT = tableconstructor;
       :}

       | STRING:string
       {:
          RESULT = new Node(string);
       :}
       ;

exp ::=  exp:exp binop:binop exptemp:exptemp
        {:
            binop.addChildren(exp);
            binop.addChildren(exptemp);
            RESULT = binop;
        :}
        | unop:unop exp:exp
        {:
            unop.addChildren(exp);
            RESULT = unop;
        :}
        | exptemp:exptemp
        {:
            RESULT = exptemp;
        :}
        ;

exptemp ::= NIL:nil
        {:
        RESULT = new Node(nil);
        :}

        | FALSE:f
        {:
             RESULT = new Node(f);
        :}

        | TRUE:t
        {:
             RESULT = new Node(t);
        :}

        | NUMBER:number
        {:
             RESULT = new Node(number);
        :}

        | STRING:string
        {:
             RESULT = new Node(string);
        :}

        | ELLIPSIS:ellipsis
        {:
             RESULT = new Node(ellipsis);
        :}

        | function:function
        {: RESULT = function; :}

        | prefixexp:prefixexp
        {: RESULT = prefixexp; :}

        | tableconstructor:tableconstructor
        {: RESULT = tableconstructor; :}
        ;

funcbody ::= OPEN_PARENTHESES:openP parlisttemp:parlisttemp CLOSE_PARENTHESES:closeP block:block END:end
            {:
                parlisttemp.addChildren(openP);
                parlisttemp.addChildren(closeP);
                block.addChildren(parlisttemp);
                block.addChildren(end);
                RESULT = block;
            :}
    
          ;

prefixexp ::= var:var
            {: RESULT = var; :}
            | functioncall: functioncall
            {: RESULT = functioncall; :}
            | OPEN_PARENTHESES:openP exp:exp CLOSE_PARENTHESES:closeP
            {: 
                exp.addChildren(openP);
                exp.addChildren(closeP);
                RESULT = exp;
            :}
            ;
