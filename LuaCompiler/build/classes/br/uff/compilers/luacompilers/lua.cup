package br.uff.compilers.luacompilers;

import java_cup.runtime.*;
import java.io.FileReader;

parser code
{:
    // Funções chamadas em erros ///////////////////////////////////////////////////////////////////////////
    public void syntax_error(Symbol s){ 
        System.out.println("\nOcorreu um erro na linha " + (s.right) +", coluna "+s.left+ ". Identificador "
        +s.value + " não reconhecido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("\nOcorreu um erro na linha " + (s.right)+ ", coluna "+s.left+". Identificador " +
        s.value + " não reconhecido.");
    }
    
    public static void main(String[] args){
        try {
            LuaParser parser = new LuaParser(new LuaLexer(new FileReader(args[0])));
            Object result = parser.parse().value;
            System.out.println("*** Resultados finais ***");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////
:}


/* Terminal */
terminal DO, END, WHILE, REPEAT, IF, THEN, ELSE, ELSEIF, FOR, IN, UNTIL;
terminal FUNCTION, LOCAL, RETURN, BREAK;
terminal NIL, FALSE, TRUE, ELLIPSIS;
terminal COLON, SEMICOLON, COMMA, OPEN_BRACKETS, CLOSE_BRACKETS, OPEN_BRACES, CLOSE_BRACES, OPEN_PARENTHESES, CLOSE_PARENTHESES;
terminal SIGN, PLUS, MINUS, TIMES, DIV, UP_CARET, PERCENT, TWO_PERIOD, PERIOD;
terminal LESS_THAN, LESS_THAN_EQUAL, GREATHER_THAN, GREATHER_THAN_EQUAL, EQUAL, DIFFERENT;
terminal AND, OR, NOT, LENGTH;
terminal NUMBER, STRING, IDENTIFIER;

non terminal chuck;
non terminal block;
non terminal stat;
non terminal laststat;
non terminal funcname;
non terminal varlist;
non terminal var;
non terminal namelist;
non terminal explist;
non terminal exp;
non terminal prefixexp;
non terminal functioncall;
non terminal args;
non terminal function;
non terminal funcbody;
non terminal parlist;
non terminal tableconstructor;
non terminal fieldlist;
non terminal field;
non terminal fieldsep;
non terminal binop;
non terminal unop;

non terminal semicolontemp;
non terminal tempchuck;
non terminal laststattemp;
non terminal elseiftemp;
non terminal elsetemp;
non terminal commaexptemp;
non terminal signexplisttemp;
non terminal explisttemp;
non terminal periodidentifiertemp;
non terminal commavartemp;
non terminal commaidentifiertemp;
non terminal expcommatemp;
non terminal parlisttemp;
non terminal commaellipsistemp;
non terminal fieldlisttemp;
non terminal fieldsepfieldtemp;
non terminal twoperiodidentifertemp;
non terminal ifstatment;
non terminal functioncalltemp;
non terminal vartemp;
non terminal exptemp;


/* Precedences */

precedence left OR;
precedence left AND;
precedence left LESS_THAN, GREATHER_THAN, LESS_THAN_EQUAL, GREATHER_THAN_EQUAL, DIFFERENT , EQUAL;
precedence right TWO_PERIOD;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, PERCENT;
precedence left NOT;
precedence right UP_CARET;
precedence left COMMA;
precedence left OPEN_PARENTHESES;

start with chuck;

chuck ::= tempchuck laststattemp
        {: System.out.println("BINIS"); :} 
        ;

tempchuck ::= stat semicolontemp tempchuck
        |
        ;

laststattemp ::= laststat semicolontemp
        |
        ;

block ::= chuck
          ;

stat ::= varlist SIGN explist
        | prefixexp 
        | DO block END
        | WHILE exp DO block END
        | REPEAT block UNTIL exp
        | ifstatment
        | FOR IDENTIFIER SIGN exp COMMA exp commaexptemp DO block END
        | FOR namelist IN explist DO block END
        | FUNCTION funcname funcbody
        | LOCAL FUNCTION IDENTIFIER funcbody
        | LOCAL namelist signexplisttemp
        ;

ifstatment ::= IF exp THEN block elseiftemp elsetemp END 
        ;

elseiftemp ::= ELSEIF exp THEN block elseiftemp
        |
        ;

elsetemp ::=  ELSE block
        |
        ;

signexplisttemp ::= SIGN explist
        |
        ;

laststat ::= RETURN explisttemp
        | BREAK
        ;

explisttemp ::= explist
        |
        ;

funcname ::= IDENTIFIER periodidentifiertemp twoperiodidentifertemp
        ;

periodidentifiertemp ::= PERIOD IDENTIFIER periodidentifiertemp
        |
        ;

twoperiodidentifertemp ::= TWO_PERIOD IDENTIFIER
        |
        ;

varlist ::= var commavartemp
        ;

var ::= IDENTIFIER
    | prefixexp vartemp;

vartemp ::= PERIOD IDENTIFIER
        | OPEN_BRACKETS exp CLOSE_BRACKETS;

namelist ::= IDENTIFIER:id commaidentifiertemp:commaidentifiertemp
        {:
        node id = new Node(id);
        commaidentifiertemp.addChildren(id);
        RESULT = commaidentifiertemp;
        :}
        ;

explist ::= exp:exp expcommatemp:expcommatemp
        {:
            expcommatemp.addChildren(exp);
            RESULT = expcommatemp;
        :}
        ;

functioncall ::= prefixexp:prefixexp functioncalltemp:functioncalltemp
            {: 
                functioncalltemp.addChildren(prefixexp);
                RESULT = functioncalltemp;
 :}
            ;

functioncalltemp ::= COLON:colon IDENTIFIER:id args:args
            {:
             Node colon = new Node(colon);
             Node id = new Node(id);
             args.addChildren(colon);
             args.addChildren(id);
             RESULT = args;
            :}


            | args:args
            {:
                RESULT = args;
            :}
            ;

function ::= FUNCTION:function funcbody:funcbody
            {:
             Node function = new Node(function);
             funcbody.addChildren(function);
             RESULT = funcbody;
            :}
          ;

parlisttemp ::= parlist:parlist
        {:
            RESULT:parlist;
        :}
        |
        ;

parlist ::= namelist:namelist commaellipsistemp:commaellipsistemp
        {:
            commaellipsistemp.addChildren(namelist);
            RESULT = commaellipsistemp;
        :}
        | ELLIPSIS:ellipsis
        {:
             RESULT = new Node(ellipsis);
        :}
        ;

tableconstructor ::=  OPEN_BRACES:openB fieldlisttemp:fieldlisttemp CLOSE_BRACES:closeB
        fieldlisttemp.addChildren(openB);
        fieldlisttemp.addChildren(closeB);
        ;

fieldlisttemp ::= fieldlist:fieldlist
        {:
            RESULT = fieldlist;
        :}
        ;

fieldlist ::= field:field fieldsepfieldtemp:fieldsepfieldtemp
        {:
            fieldsepfieldtemp.addChildren(field);
            RESULT = fieldsepfieldtemp;
        :}
        ;

fieldsepfieldtemp ::= fieldsep:fieldsep field:field fieldsepfieldtemp:fieldsepfieldtemp 
        {:
            fieldsepfieldtemp.addChildren(fieldesp);
            fieldsepfieldtemp.addChildren(field);
            RESULT = fieldsepfieldtemp
        :}
        
        |
        ;

field ::= OPEN_BRACKETS exp CLOSE_BRACKETS SIGN exp
        | IDENTIFIER:id SIGN:sign exp:exp
        {:
            Node id = new Node(id);
            Node sign = new Node(sign);
            exp.addChildren(id);
            exp.addChildren(sign);
            RESULT = exp;
        :}
        | exp:exp
        {:
          RESULT = exp;
        :}
        |
        ;
            
binop ::= PLUS:plus
        {:
            RESULT = new Node(plus);
        :}
        | MINUS:minus
        {:
            RESULT = new Node(minus);
        :}
        | TIMES:times
        {:
            RESULT = new Node(times);
        :}
        | DIV:div
        {:
            RESULT = new Node(div);
        :}
        | UP_CARET:up_caret
        {:
            RESULT = new Node(up_caret);

        :}
        | PERCENT:percent
        {:
            RESULT = new Node(percent);
        :}
        | TWO_PERIOD:two_period
        {:
            RESULT = new Node(two_period);
        :}
        | LESS_THAN:less_than
        {:
            RESULT = new Node(less_than);
        :}
        | LESS_THAN_EQUAL:less_than_equal
        {:
            RESULT = new Node(less_than_equal);
        :}
        | GREATHER_THAN:greather_than
        {:
            RESULT = new Node(greather_than);
        :}
        | GREATHER_THAN_EQUAL:greather_than_equal
        {:
            RESULT = new Node(greather_than_equal);
        :}
        | EQUAL: equal
        {:
            RESULT = new Node(equal);

        :}
        | DIFFERENT:different
        {:
            RESULT = new Node(different);

        :}
        | AND:and
        {:
            RESULT = new Node(result);

        :}
        | OR:or
        {:
            RESULT = new Node(or);

        :}
        ;

unop ::= MINUS:minus
        {:
            RESULT = new Node(minus);
        :}
       | NOT:not
        {:
            RESULT = new Node(not);
        :}
       | LENGTH:length
        {:
            RESULT = new Node(length);
        :}
       ;

semicolontemp ::= SEMICOLON:semicolon
        {:
            RESULT = new Node(semicolon);

        :}
        |
        ;

fieldsep ::= COMMA:comma
        {:
            RESULT = new Node(comma);
        :}
        | SEMICOLON:semicolon
        {:
            RESULT = new Node(semicolon);

        :}
        ;


commaellipsistemp ::= COMMA:comma ELLIPSIS:ellipsis 
        {:
        Node comma = new Node(comma);
        Node ellipsis = new Node(ellipsis);
        ellipsis.addChildren(comma);
        RESULT = ellipsis;
:}
        |
        ;

expcommatemp ::= COMMA:comma exp:exp expcommatemp:expcommatemp
        {:
        Node comma = new Node(comma);
        expcommatemp.addChildren(comma);
        expcommatemp.addChildren(exp);
        RESULT = expcommatemp
        :}
        |
        ;

commaidentifiertemp ::= COMMA:comma IDENTIFIER:id commaidentifiertemp:commaidentifiertemp
        {:
            Node comma = new Node(comma);
            Node id = new Node(id);
            commaidentifiertemp.addChildren(comma);
            commaidentifiertemp.addChidren(id);
            RESULT = commaidentifiertemp;
        :}
        |
        ;

commavartemp ::= COMMA:comma var:var commavartemp:commavartemp
        {:
            Node comma = new Node(comma);
            commavartemp.addChildren(comma);
            commavartemp.addChildren(var);
            RESULT = commavartemp;
        :}
        |
        ;

commaexptemp ::= COMMA:comma exp:exp
        {:
            Node comma = new Node(comma);
            comma.addChildren(exp);
            RESULT = comma;
        :}
        |
        ;

args ::= OPEN_PARENTHESES:openP explisttemp:explisttemp CLOSE_PARENTHESES:closeP
        {:
            explisttemp.addChildren(openP)
            explisttemp.addChildren(closeP)
            RESULT = explisttemp
        :}
    
       | tableconstructor:tableconstructor
       {:
          RESULT = tableconstructor
       :}

       | STRING:string
       {:
          RESULT = new Node(string);
       :}
       ;

exp ::=  exp:exp binop:binop exptemp:exptemp
        {:
            binop.addChildren(exp)
            binop.addChildren(exptemp)
            RESULT = binop
        :}
        | unop:unop exp:exp
        {:
            unop.addChildren(exp)
            RESULT = unop
        :}
        | exptemp:exptemp
        {:
            RESULT = exptemp
        :}
        ;

exptemp ::= NIL:nil
        {:
        RESULT = new Node(nil);
        :}

        | FALSE:false
        {:
             RESULT = new Node(flask);
        :}

        | TRUE:true
        {:
             RESULT = new Node(true);
        :}

        | NUMBER:number
        {:
             RESULT = new Node(number);
        :}

        | STRING:string
        {:
             RESULT = new Node(string);
        :}

        | ELLIPSIS:ellipsis
        {:
             RESULT = new Node(ellipsis);
        :}

        | function:function
        {: RESULT = function; :}

        | prefixexp:prefixexp
        {: RESULT = prefixexp; :}

        | tableconstructor:tableconstructor
        {: RESULT = tableconstructor :}
        ;

funcbody ::= OPEN_PARENTHESES:openP parlisttemp:parlisttemp CLOSE_PARENTHESES:closeP block:block END:end
            {:
                parlisttemp.addChildren(openP)
                parlisttemp.addChildren(closeP)
                block.addChildren(parlisttemp)
                block.addChildren(end)
                RESULT = block
            :}
    
          ;

prefixexp ::= var:var
            {: RESULT = var :}
            | functioncall: functioncall
            {: RESULT = functioncall :}
            | OPEN_PARENTHESES:openP exp:exp CLOSE_PARENTHESES:closeP
            {: 
                exp.addChildren(openP)
                exp.addChildren(closeP)
                RESULT = exp
            :}
            ;
